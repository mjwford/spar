#!/usr/bin/env python3


import sys
from math import *
from std_msgs.msg import Bool
import rospy
import actionlib
import math
from actionlib_msgs.msg import GoalStatus
from espeak import espeak
from std_msgs.msg import String

from sensor_msgs.msg import BatteryState

from geometry_msgs.msg import Point, PoseStamped

from nav_msgs.msg import Path

from spar_msgs.msg import FlightMotionAction, FlightMotionGoal

# Libraries for interfacing with BreadCrumb
from breadcrumb.srv import RequestPath
from breadcrumb.srv import RequestPathRequest


#rostopic pub /mavros/battery sensor_msgs/BatteryState '{percentage: 20.0}'


# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class Guidance():
	def __init__(self, waypoints, extended_waypoints):
		# Make sure we have a valid waypoint list
		# Safe boundary values, default to X<2,Y<2,Z<2.
		self.safeRangeX = rospy.get_param("~safeRangeX", 4)
		self.safeRangeY = rospy.get_param("~safeRangeY", 2.5)
		self.safeRangeZ = rospy.get_param("~safeRangeZ", 4) 

		#Setup variable to store landing information.
		self.landing_coordinate = None
		self.detected_landing_point = False

		self.topic_battery = '/mavros/battery'
		self.battery_per = 100
		self.critical_battery = 20
		
		self.landing_variable = None

		#Imaging variables.
		self.detected_bag = False
		self.detected_person = False

		if not self.check_waypoints(waypoints):
			raise ArgumentError("Invalid waypoint list input!")

		# Internal counter to see what waypoint were are up to
		self.nextWaypointIndex = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False

		# Save the input waypoints
		self.waypoints = extended_waypoints
		self.og_waypoints = waypoints
		# Display the full path
		self.display_path(waypoints,"/guidance/fullPath")

		# Make some space to record down our current location
		self.current_location = Point()
		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear", 0.2)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)
		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.1)
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 0.1)
		# Get survey altitude
		self.surveyAltitude = rospy.get_param("~surveyAlt", 1)

		# Create our action client
		action_ns = rospy.get_param("~action_topic", 'spar/flight')
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()

		# Wait to connect with Breadcrumb (Warning, you code might get stuck in here if breadcrumb is not running)
		# Code will error if you try to connect to a service
		# that does not exist
		rospy.wait_for_service('/breadcrumb/request_path')
		self.srvc_bc = rospy.ServiceProxy('/breadcrumb/request_path', RequestPath)

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission")


			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)
			self.current_position_publisher = rospy.Publisher("current_position", Point, queue_size=10)
			

			#Espeak publisher.
			self.espeak_publisher = rospy.Publisher("espeak_topic", String, queue_size=10)
			

			#Payload publisher.
			#rostopic pub /actuator_control/actuator_a std_msgs/Bool '{data: True}'
			self.payload_pub = rospy.Publisher("/actuator_control/actuator_a", Bool, queue_size=10)


			# Setup first waypoint segment
			# XXX:	Another option would be to do "takeoff" and leave "nextWaypointIndex = 0" to
			#		begin the mission at the first waypoint after take-off
			
			
			#DO TAKEOFF HERE.
			# ASK IF MORE NECESSARY
			self.send_takeoff_motion(self.spar_client)
			# ASK IF MORE NECESSARY
			
			rospy.loginfo("Doing first waypoint / maybe takeoff")
			self.send_wp(self.waypoints[0])
			self.nextWaypointIndex += 1
			# Initialisation breadcrumb waypoints
			self.breadcrumbWPSnextIndex = 0
			self.breadcrumbMode = False
			self.breadcrumbWPS = []

			# Setup a timer to check if our waypoint has completed at 20Hz
			rospy.loginfo("Setting callbacks")
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			# XXX: These topics could be hard-coded to avoid using a launch file
			self.sub_pose = rospy.Subscriber("~pose", PoseStamped, self.callback_pose)
			# Subscriber to catch "ROI" diversion commands
			self.sub_roi = rospy.Subscriber("~roi", PoseStamped, self.callback_inspect_roi)

			# Subscriber for current battery
			self.sub_battery = rospy.Subscriber(self.topic_battery, BatteryState, self.callback_battery)

			#Setup subscriber for landing ArUco detection.
			self.sub_landing_coordinate = rospy.Subscriber("landing_id_coordinate", Point, self.callback_landing_coordinate)

			self.final_coordinate_start = False
			self.final_coordinate_finished = False
	
			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.loginfo("Running callbacks while not shutdown...")
			rospy.on_shutdown( lambda : self.shutdown() )

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):
		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("Waypoint %i did not pass check" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("Waypoint is not a list of coordinates")
			return False

		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False

		# Check if the waypoint is inside the net for X, Y and Z:
		if abs(wp[0]) > self.safeRangeX or abs(wp[1]) > self.safeRangeY or wp[2] > self.safeRangeZ:
			rospy.logwarn("Waypoint has an invalid size for O134 (must be -{}<X<{}/-{}<Y<{}/Z<{}/Yaw)".format(self.safeRangeX,self.safeRangeX,self.safeRangeY,self.safeRangeY,self.safeRangeZ))
			return False

		# If we haven't returned false yet, then waypoint looks valid!
		return True


	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		# Unregister anything that needs it here
		rospy.loginfo("Unregistering topics and shuting down...")
		self.sub_pose.unregister()
		self.sub_roi.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("Guidance stopped")


	# This function will check receive the current pose of the UAV constantly
	def callback_pose(self, msg_in):
		# Store the current position at all times so it can be accessed later
		# rospy.loginfo("Updating Pose UAV...")
		self.current_position_publisher.publish(self.current_location)
		self.current_location = msg_in.pose.position


	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in):

		rospy.loginfo(msg_in.pose.position.z)		

		if ((msg_in.pose.position.z == 0) and (not self.detected_bag)) or ((msg_in.pose.position.z == 1) and (not self.detected_person)):

			# Set our flag that we are performing the diversion
			self.performing_roi = True

			rospy.loginfo("Starting diversion to ROI...")
			# Cancel the current goal (if there is one)
			self.spar_client.cancel_goal()
			# Record our current location so we can return to it later
			start_location = self.current_location
			# XXX:	It would also be a good idea to capture "current yaw" from
			#		the pose to maintain that throughout a diversion


		
			if(msg_in.pose.position.z == 0):
				rospy.loginfo("BAG Detected...")
				self.detected_bag = True
				#espeak.synth("Starting diversion to ROI")
				self.espeak_publisher.publish("Bag detected. Starting diversion to ROI")
			elif(msg_in.pose.position.z == 1):
				rospy.loginfo("PERSON Detected...")
				self.detected_person = True
				#espeak.synth("Starting diversion to ROI")
				self.espeak_publisher.publish("Person detected. Starting diversion to ROI")


			

			

			# Set the "diversion waypoint" (at yaw zero)
			# dwp = [msg_in.pose.position.x, msg_in.pose.position.y, msg_in.pose.position.z, 0.0]
			#dwp = [msg_in.pose.position.x, msg_in.pose.position.y, self.current_location.z, 0.0]
			dwp = [msg_in.pose.position.x, msg_in.pose.position.y, 0.65, 0.0]
			
			
			
			
			# Set the "return waypoint" (at yaw zero)
			rwp = [self.current_location.x, self.current_location.y, self.current_location.z, 0.0]

			# XXX: Could pause here for a moment with ( "rospy.sleep(...)" ) to make sure the UAV stops correctly

			self.send_wp(dwp)
			self.spar_client.wait_for_result()
			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				# Something went wrong, cancel out of guidance!
				rospy.signal_shutdown("cancelled")
				return

			rospy.loginfo("Reached diversion ROI, dropping payload!")
			# XXX: Do something? DROP THE PAYLOAD.
			#rostopic pub /actuator_control/actuator_a std_msgs/Bool '{data: True}'
			if(msg_in.pose.position.z == 0):
				self.payload_pub.publish(False)
				#espeak.synth("Deploying GPS Tracker")
				self.espeak_publisher.publish("Deploying GPS Tracker")
			elif(msg_in.pose.position.z == 1):
				self.payload_pub.publish(True)
				#espeak.synth("Deploying Epi-Pen")
				self.espeak_publisher.publish("Deploying Epi-Pen")

			rospy.sleep(rospy.Duration(5))

			

			rospy.loginfo("Returning to flight plan...")

			self.send_wp(rwp)
			self.spar_client.wait_for_result()

			#Shorten the path to one sweep if both are detected.
			if(self.detected_bag and self.detected_person and self.detected_landing_point):
				self.do_landing_stuff()

				#Both people are detected, shorten the coordinates. 

			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				# Something went wrong, cancel out of guidance!
				rospy.signal_shutdown("cancelled")
				return

			# "nextWaypointIndex" represents the "next waypoint"
			# "nextWaypointIndex - 1" represents the "current waypoint"
			rospy.loginfo("Resuming flight plan from waypoint %i!" % (self.nextWaypointIndex - 1))
			self.send_wp(self.waypoints[self.nextWaypointIndex - 1])
			# Unset our flag that we are performing a diversion
			# to allow the waypoint timer to take back over
			self.performing_roi = False


	# This function is for convinience to simply send out a new waypoint
	def send_wp(self, wp):


		rospy.loginfo("SENT CURRENT LOCATION")

		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			rospy.logwarn("Invalid waypoint, skipped...")
			return False
			# raise ArgumentError("Invalid waypoint input!")

		# Build the flight goal
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_GOTO
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		goal.yaw = wp[3]
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw
		goal.wait_for_convergence = True
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# For this function, we don't wait in the loop.
		# Instead we just send the waypoint and check up on it later
		# This checking is either with the "self.timer" for waypoints
		# or with direct calls during the ROI diversion
		self.spar_client.send_goal(goal)
		
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())


	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not self.performing_roi:
			# If the last segment has succeeded.
			# For more complex tasks, it might be necessary to also
			# check if you are in waypoint or breadcrum mode.
			# Hint: really, we should check for other status states
			#		(such as aborted), as there are some states
			#		where we won't recover from, and should just exit
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo("Reached waypoint %i!" % (self.nextWaypointIndex))

				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				if self.nextWaypointIndex < (len(self.waypoints)):

					if not self.breadcrumbMode:
						# Set up a path request for breadcrumb
						req = RequestPathRequest()
						req.start.x = self.waypoints[self.nextWaypointIndex-1][0] # Get X
						req.start.y = self.waypoints[self.nextWaypointIndex-1][1] # Get Y
						req.start.z = self.waypoints[self.nextWaypointIndex-1][2] # Get Z
						req.end.x = self.waypoints[self.nextWaypointIndex][0]	# Get next X
						req.end.y = self.waypoints[self.nextWaypointIndex][1]	# Get next Y
						req.end.z = self.waypoints[self.nextWaypointIndex][2]	# Get next Z

						res = self.srvc_bc(req)
						
						# Breadcrumb will return a vector of poses if a solution was found
						# If no solution was found (i.e. no solution, or request bad
						# start/end), then breadcrumb returns and empty vector
						# XXX: You could also use res.path_sparse (see breadcrumb docs)
						breadcrumbWPS = []
						if len(res.path_sparse.poses) > 0:
							# Print the path to the screen
							rospy.loginfo("Segment {}-1 to {}:".format(self.nextWaypointIndex,self.nextWaypointIndex))
							rospy.loginfo("[%0.2f;%0.2f;%0.2f] => [%0.2f;%0.2f;%0.2f]",
										req.start.x,req.start.y,req.start.z,
										req.end.x,req.end.y,req.end.z)

							# Loop through the solution returned from breadcrumb
							for i in range(len(res.path_sparse.poses)):
								rospy.loginfo("    [%0.2f;%0.2f;%0.2f]",
											res.path_sparse.poses[i].position.x,
											res.path_sparse.poses[i].position.y,
											res.path_sparse.poses[i].position.z)
								breadcrumbWPS.append([res.path_sparse.poses[i].position.x, res.path_sparse.poses[i].position.y, res.path_sparse.poses[i].position.z, 0.0])

							# Display the path
							# print(breadcrumbWPS)
							self.breadcrumbWPS = breadcrumbWPS
							self.display_path(breadcrumbWPS,"/guidance/pathBreadcrum")
							self.breadcrumbMode = True
							self.breadcrumbWPSnextIndex = 0
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							self.breadcrumbWPSnextIndex +=1 

						else:
							rospy.logerr("solution not found")

					else:
						if self.breadcrumbWPSnextIndex < (len(self.breadcrumbWPS)):
							# We got here a breadcrumb path, we should exuted down here:
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							# Increment our waypoint counter
							self.breadcrumbWPSnextIndex +=1
						else:
							# If we finish with the breadcrumb waypoints we increase normal waypoints
							self.nextWaypointIndex += 1
							self.breadcrumbMode = False
				else:
					# Else the mission is over, shutdown and quit the node
					# XXX:	This could be used to restart the mission back to the
					#		first waypoint instead to restart the mission


					#If landing point was detected then go there.	
					#if self.detected_landing_point:
					#	if not self.final_coordinate_start:
					#		self.final_coordinate_finished = False
					#		self.send_wp([self.landing_coordinate.x, self.landing_coordinate.y, self.landing_coordinate.z, 0])
					#		self.final_coordinate_start = True
					#		rospy.loginfo("fuck you")
					#
					#
					#	if self.final_coordinate_finished and self.final_coordinate_start:
					#		rospy.loginfo("Mission csdsdfdsfdsfdsfsdf;")
					#		rospy.signal_shutdown("Complete, Wooh!")
					#else:
					#	rospy.loginfo("Mission complete1!")
					#	rospy.signal_shutdown("Complete, Wooh!")
					rospy.loginfo("Mission complete1!")
					rospy.signal_shutdown("Complete, Wooh!")


			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				rospy.loginfo("Mission cancelled! smoge")
				rospy.signal_shutdown("cancelled")

	# Display a path
	def display_path(self, wps, name):
		rospy.loginfo("Displaying path...")
		pub_path = rospy.Publisher(name, Path, queue_size=10, latch=True)
		msg = Path()
		msg.header.frame_id = "/map"
		msg.header.stamp = rospy.Time.now()
	
		for wp in wps:
			pose = PoseStamped()
			pose.pose.position.x = wp[0]
			pose.pose.position.y = wp[1]
			pose.pose.position.z = wp[2]
	
			pose.pose.orientation.w = 1.0
			pose.pose.orientation.x = 0.0
			pose.pose.orientation.y = 0.0
			pose.pose.orientation.z = 0.0
	
			msg.poses.append(pose)
		rospy.loginfo("Publishing path...")
		pub_path.publish(msg)

	def callback_landing_coordinate(self, msg_in):
		self.landing_variable = [msg_in.x, msg_in.y, 0.35, 0.0]
		if not self.detected_landing_point:
			#espeak.synth("Landing coordinates detected")
			self.espeak_publisher.publish("Landing coordinates detected")
			rospy.loginfo("Detected landing coordinate.")
			rospy.loginfo(msg_in.x)
			rospy.loginfo(msg_in.y)
			rospy.loginfo(msg_in.z)
			self.landing_coordinate = msg_in
			self.detected_landing_point = True

			self.waypoints.append([msg_in.x, self.waypoints[len(self.waypoints) - 1][1], 1, 0])
			self.waypoints.append([self.waypoints[len(self.waypoints) - 1][0], msg_in.y, 1, 0])

			self.landing_variable = [self.waypoints[len(self.waypoints) - 1][0], self.waypoints[len(self.waypoints) - 1][1], 0.35, 0.0]

			#Shorten the path to one sweep if both are detected.
			if(self.detected_bag and self.detected_person and self.detected_landing_point):
				
				
				
				
				#if((self.nextWaypointIndex-1) <= (len(self.waypoints) / 2)):
				#	self.waypoints = self.og_waypoints + self.waypoints[-2:]
				#elif ((self.nextWaypointIndex - 1) < (len(self.waypoints) - 2)):
				#	self.waypoints = self.waypoints[:self.nextWaypointIndex] + self.waypoints[-2:]
				#
				#Both people are detected, shorten the coordinates. 
				self.do_landing_stuff()

				
	def do_landing_stuff(self):
		#Switched from above to abdulleys stuff.
		self.performing_roi = True
		self.spar_client.cancel_goal()
		self.send_wp(self.landing_variable)
		self.spar_client.wait_for_result()
		self.send_wp([self.landing_variable[0], self.landing_variable[1], 3, 0.0])
		rospy.sleep(rospy.Duration(5, 0))
		self.send_wp([self.landing_variable[0], self.landing_variable[1], 0.35, 0.0])
		self.spar_client.wait_for_result()
		rospy.sleep(rospy.Duration(5, 0))
		self.send_landing_motion(self.spar_client)



	def callback_battery(self, msg_in):
		self.battery_per = msg_in.percentage
		rospy.loginfo(msg_in.percentage)
		#self.uav_health()

	def uav_health(self, timer=None):
		if self.battery_per <= self.critical_battery:
			rospy.loginfo("Battery under critical level, Safe landing start.")
			rospy.loginfo(self.battery_per)

			#Code for emergency landing at -1,-1.
			
			#WHEN THIS RUNS DURING PAYLOAD DEPLOYMENT IT GOES TO THE LAST 
			#WAYPOINT BECAUSE IT GOES BACK TO THE SEND-WP AND THINKS ITS
			#AT THE LAST WAYPOINT.


			self.nextWaypointIndex = len(self.waypoints)

			self.send_wp([-1.0, -1.0, 0.6, 0])
	
		
			rospy.loginfo("Emergency land completed.")

	def send_takeoff_motion(self, spar_client):
		# Create our goal
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_TAKEOFF
		goal.position.z = rospy.get_param("~height", 1.0)			# Other position information is ignored
		goal.velocity_vertical = rospy.get_param("~speed", 0.2)		# Other velocity information is ignored
		goal.wait_for_convergence = True							# Wait for our takeoff "waypoint" to be reached
		goal.position_radius = rospy.get_param("~position_radius", 0.3)
		goal.yaw_range = rospy.get_param("~yaw_range", 0.1)

		# Send the goal
		rospy.loginfo("Sending goal motion...")
		spar_client.send_goal(goal)
		# If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : spar_client.cancel_goal())
		# Wait for the result of the goal
		spar_client.wait_for_result()

		# Output some feedback for our flight
		result = spar_client.get_state()
		if result == GoalStatus.SUCCEEDED:
			rospy.loginfo("Take-off complete!")
		else:
			rospy.logerr("Take-off failed!")

			# Detailed Feedback
			if result != GoalStatus.SUCCEEDED:
				if(result == GoalStatus.PENDING) or (result == GoalStatus.ACTIVE):
					rospy.loginfo("Sent command to cancel current mission")
				elif(result == GoalStatus.PREEMPTED):
					rospy.logwarn("The current mission was cancelled")
				elif(result == GoalStatus.ABORTED):
					rospy.logwarn("The current mission was aborted")
				elif(result == GoalStatus.RECALLED):
					rospy.logerr("Error: The current mission was recalled")
				elif(result == GoalStatus.REJECTED):
					rospy.logerr("Error: The current mission was rejected")
				else:
					rospy.logerr("Error: An unknown goal status was recieved")

	def send_landing_motion(self, spar_client):
		# Create our goal
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_LAND
		goal.velocity_vertical = rospy.get_param("~speed", 0.2)		# Other velocity information is ignored
		# No other information is used

		# Send the goal
		rospy.loginfo("Sending goal motion...")
		spar_client.send_goal(goal)
		# If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : spar_client.cancel_goal())
		# Wait for the result of the goal
		spar_client.wait_for_result()

		# Output some feedback for our flight
		result = spar_client.get_state()
		if result == GoalStatus.SUCCEEDED:
			rospy.loginfo("Landing complete!")
		else:
			rospy.logerr("Landing failed!")

			# Detailed Feedback
			if result != GoalStatus.SUCCEEDED:
				if(result == GoalStatus.PENDING) or (result == GoalStatus.ACTIVE):
					rospy.loginfo("Sent command to cancel current mission")
				elif(result == GoalStatus.PREEMPTED):
					rospy.logwarn("The current mission was cancelled")
				elif(result == GoalStatus.ABORTED):
					rospy.logwarn("The current mission was aborted")
				elif(result == GoalStatus.RECALLED):
					rospy.logerr("Error: The current mission was recalled")
				elif(result == GoalStatus.REJECTED):
					rospy.logerr("Error: The current mission was rejected")
				else:
					rospy.logerr("Error: An unknown goal status was recieved")


#Generates waypoints given search area, altitude, FOV and overlap.
#(Search area as observed standing from the desk x-> horizontal, y-> vertical).
#(FOV is taken as half of the angle of the camera (something like 19 degrees i think)).
#(NEED TO IMPORT MATH).
#SEE THE COMMENT "EXTREMELY IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!"
def generate_waypoints(search_x, search_y, altitude, fov, overlap):

	#Calculate pass length. 
	image_length = 2 * (altitude * math.tan(fov*(math.pi/180)))
	pass_length = image_length * (1.0 - overlap)

	#Calculate number of passes required.
	num_passes = int(math.ceil(search_y / pass_length))

	#Create waypoints (two waypoints per pass).
	waypoint_list = []
	for waypoint_index in range(num_passes):
		
		#X position is the same for both waypoints in one pass. 
		#waypoint_x = (((search_x / pass_length) * (waypoint_index + 1)) + (pass_length/2))
		waypoint_y = (pass_length / 2) + (pass_length * waypoint_index)
		waypoint_y_zeroed = waypoint_y - (search_y / 2)

		#Y position is the same but opposite.
		waypoint_x_top = (search_x/2) - (pass_length/2)
		waypoint_x_bottom = -1 * waypoint_x_top

		#Waypoints.
		#EXTREMELY IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!
		#The actual room is flipped, x is y, y is x. So here, the values are just added in reverse. 
		top_waypoint = [float(waypoint_x_top), float(waypoint_y_zeroed), float(altitude), 0.0]
		bottom_waypoint = [float(waypoint_x_bottom), float(waypoint_y_zeroed), float(altitude), 0.0]

		#If the index is even, bottom is first...etc.
		if (waypoint_index % 2) == 0: #Even.
			waypoint_list.append(bottom_waypoint)
			waypoint_list.append(top_waypoint)
		else: #Odd.
			waypoint_list.append(top_waypoint)
			waypoint_list.append(bottom_waypoint)

	#Return the waypoint list.
	return waypoint_list	



	

def main(args):
	# Initialise ROS
	rospy.init_node('guidance')
	surveyAltitude = rospy.get_param("~surveyAlt", 1)
	# List of waypoints
	# surveyAltitude = 2.5
	# [X, Y, Z, Yaw]
	# wpsR1 = [[ 0.0, 0.0, surveyAltitude, 0.0],
	# 	   [ 1.0, 1.0, surveyAltitude, 0.0],
	# 	   [-1.0, 1.0, surveyAltitude, 0.0],
	# 	   [-1.0,-1.0, surveyAltitude, 0.0],
	# 	   [ 1.0,-1.0, surveyAltitude, 0.0],
	# 	   [ 0.0, 0.0, surveyAltitude, 0.0]]

	# wpsR2 = [[ 0.0, 0.0, surveyAltitude*2, 0.0],
	# 	   [ 1.0, 1.0, surveyAltitude*2, 0.0],
	# 	   [-1.0, 1.0, surveyAltitude*2, 0.0],
	# 	   [-1.0,-1.0, surveyAltitude*2, 0.0],
	# 	   [ 1.3,-1.0, surveyAltitude*2, 0.0],
	# 	   [ 1.3,1.0, surveyAltitude*2, 0.0],
	# 	   [ 1.0,-1.0, surveyAltitude*2, 0.0],
	# 	   [ 0.0, 0.0, surveyAltitude*2, 0.0]]

	# #Lawnmower pattern.
	# lawn_alt = 3
	# lawn_wps = [[ 0.0, 0.0, lawn_alt , 0.0],
	# 	   [-3.5, 0.0, lawn_alt , 0.0],
	# 	   [ -3.5, -2.0,lawn_alt, 0.0],
	# 	   [3.5, -2.0, lawn_alt, 0.0],
	# 	   [3.5,-1.0, lawn_alt, 0.0],
	# 	   [ -3.5,-1.0, lawn_alt, 0.0],
	# 	   [ -3.5,0.0, lawn_alt, 0.0],
	# 	   [ 3.5 ,0.0, lawn_alt, 0.0],
	# 	   [ 3.5, 1.0, lawn_alt, 0.0],
	# 	   [ -3.5, 1.0, lawn_alt, 0.0],
	# 	   [ -3.5, 2.0, lawn_alt, 0.0],
	# 	   [ 3.5, 2.0, lawn_alt, 0.0]]

	# if surveyAltitude > 2:
	# 	wps = wpsR1
	# else:
	# 	wps = wpsR2

	x = 8
	y = 5
	alt = 3
	fov = 19.59
	overlap = 0.4 #40%.
	
	lawn_wps = generate_waypoints(x, y, alt, fov, overlap)
	
	reversed_lawn_wps = lawn_wps[:-1][::-1]

	lawn_wps_extended = lawn_wps + reversed_lawn_wps


	# lawn_alt = 3
	# lawn_wps = [[ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	# 	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	# 	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0]]

	

	# Create our guidance class option
	guide = Guidance(lawn_wps, lawn_wps_extended)

	# Spin!
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('Node Closed')





#rostopic pub /pose_example geometry_msgs/PoseStamped "header:
#  seq: 0
#  stamp:
#    secs: 0
#    nsecs: 0
#  frame_id: 'base_link'
#pose:
#  position:
#    x: 1.0
#    y: 2.0
#    z: 0.0
#  orientation:
#    x: 0.0
#    y: 0.0
#    z: 0.0
#    w: 1.0"




'''
import sys
from math import *
from std_msgs.msg import Bool
import rospy
import actionlib
import math
from actionlib_msgs.msg import GoalStatus
from espeak import espeak
from std_msgs.msg import String

from sensor_msgs.msg import BatteryState

from geometry_msgs.msg import Point, PoseStamped

from nav_msgs.msg import Path

from spar_msgs.msg import FlightMotionAction, FlightMotionGoal

# Libraries for interfacing with BreadCrumb
from breadcrumb.srv import RequestPath
from breadcrumb.srv import RequestPathRequest


#rostopic pub /mavros/battery sensor_msgs/BatteryState '{percentage: 20.0}'


# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class Guidance():
	def __init__(self, waypoints):
		# Make sure we have a valid waypoint list
		# Safe boundary values, default to X<2,Y<2,Z<2.
		self.safeRangeX = rospy.get_param("~safeRangeX", 4)
		self.safeRangeY = rospy.get_param("~safeRangeY", 2.5)
		self.safeRangeZ = rospy.get_param("~safeRangeZ", 4) 

		#Setup variable to store landing information.
		self.landing_coordinate = None
		self.detected_landing_point = False

		self.topic_battery = '/mavros/battery'
		self.battery_per = 100
		self.critical_battery = 20
		
	

		#Imaging variables.
		self.detected_bag = False
		self.detected_person = False

		if not self.check_waypoints(waypoints):
			raise ArgumentError("Invalid waypoint list input!")

		# Internal counter to see what waypoint were are up to
		self.nextWaypointIndex = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False

		# Save the input waypoints
		self.waypoints = waypoints
		# Display the full path
		self.display_path(waypoints,"/guidance/fullPath")

		# Make some space to record down our current location
		self.current_location = Point()
		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear", 0.2)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)
		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.1)
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 0.1)
		# Get survey altitude
		self.surveyAltitude = rospy.get_param("~surveyAlt", 1)

		# Create our action client
		action_ns = rospy.get_param("~action_topic", 'spar/flight')
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()

		# Wait to connect with Breadcrumb (Warning, you code might get stuck in here if breadcrumb is not running)
		# Code will error if you try to connect to a service
		# that does not exist
		rospy.wait_for_service('/breadcrumb/request_path')
		self.srvc_bc = rospy.ServiceProxy('/breadcrumb/request_path', RequestPath)

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission")


			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)
			self.current_position_publisher = rospy.Publisher("current_position", Point, queue_size=10)
			

			#Espeak publisher.
			self.espeak_publisher = rospy.Publisher("espeak_topic", String, queue_size=10)
			

			#Payload publisher.
			#rostopic pub /actuator_control/actuator_a std_msgs/Bool '{data: True}'
			self.payload_pub = rospy.Publisher("/actuator_control/actuator_a", Bool, queue_size=10)


			# Setup first waypoint segment
			# XXX:	Another option would be to do "takeoff" and leave "nextWaypointIndex = 0" to
			#		begin the mission at the first waypoint after take-off
			rospy.loginfo("Doing first waypoint / maybe takeoff")
			self.send_wp(self.waypoints[0])
			self.nextWaypointIndex += 1
			# Initialisation breadcrumb waypoints
			self.breadcrumbWPSnextIndex = 0
			self.breadcrumbMode = False
			self.breadcrumbWPS = []

			# Setup a timer to check if our waypoint has completed at 20Hz
			rospy.loginfo("Setting callbacks")
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			# XXX: These topics could be hard-coded to avoid using a launch file
			self.sub_pose = rospy.Subscriber("~pose", PoseStamped, self.callback_pose)
			# Subscriber to catch "ROI" diversion commands
			self.sub_roi = rospy.Subscriber("~roi", PoseStamped, self.callback_inspect_roi)

			# Subscriber for current battery
			self.sub_battery = rospy.Subscriber(self.topic_battery, BatteryState, self.callback_battery)

			#Setup subscriber for landing ArUco detection.
			self.sub_landing_coordinate = rospy.Subscriber("landing_id_coordinate", Point, self.callback_landing_coordinate)

			self.final_coordinate_start = False
			self.final_coordinate_finished = False
	
			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.loginfo("Running callbacks while not shutdown...")
			rospy.on_shutdown( lambda : self.shutdown() )

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):
		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("Waypoint %i did not pass check" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("Waypoint is not a list of coordinates")
			return False

		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False

		# Check if the waypoint is inside the net for X, Y and Z:
		if abs(wp[0]) > self.safeRangeX or abs(wp[1]) > self.safeRangeY or wp[2] > self.safeRangeZ:
			rospy.logwarn("Waypoint has an invalid size for O134 (must be -{}<X<{}/-{}<Y<{}/Z<{}/Yaw)".format(self.safeRangeX,self.safeRangeX,self.safeRangeY,self.safeRangeY,self.safeRangeZ))
			return False

		# If we haven't returned false yet, then waypoint looks valid!
		return True


	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		# Unregister anything that needs it here
		rospy.loginfo("Unregistering topics and shuting down...")
		self.sub_pose.unregister()
		self.sub_roi.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("Guidance stopped")


	# This function will check receive the current pose of the UAV constantly
	def callback_pose(self, msg_in):
		# Store the current position at all times so it can be accessed later
		# rospy.loginfo("Updating Pose UAV...")
		self.current_position_publisher.publish(self.current_location)
		self.current_location = msg_in.pose.position


	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in):

		rospy.loginfo(msg_in.pose.position.z)		

		if ((msg_in.pose.position.z == 0) and (not self.detected_bag)) or ((msg_in.pose.position.z == 1) and (not self.detected_person)):

			# Set our flag that we are performing the diversion
			self.performing_roi = True

			rospy.loginfo("Starting diversion to ROI...")
			# Cancel the current goal (if there is one)
			self.spar_client.cancel_goal()
			# Record our current location so we can return to it later
			start_location = self.current_location
			# XXX:	It would also be a good idea to capture "current yaw" from
			#		the pose to maintain that throughout a diversion


		
			if(msg_in.pose.position.z == 0):
				rospy.loginfo("BAG Detected...")
				self.detected_bag = True
			elif(msg_in.pose.position.z == 1):
				rospy.loginfo("PERSON Detected...")
				self.detected_person = True

			# Set the "diversion waypoint" (at yaw zero)
			# dwp = [msg_in.pose.position.x, msg_in.pose.position.y, msg_in.pose.position.z, 0.0]
			#dwp = [msg_in.pose.position.x, msg_in.pose.position.y, self.current_location.z, 0.0]
			dwp = [msg_in.pose.position.x, msg_in.pose.position.y, 0.65, 0.0]
			
			
			#espeak.synth("Starting diversion to ROI")
			self.espeak_publisher.publish("Starting diversion to ROI")
			
			# Set the "return waypoint" (at yaw zero)
			rwp = [self.current_location.x, self.current_location.y, self.current_location.z, 0.0]

			# XXX: Could pause here for a moment with ( "rospy.sleep(...)" ) to make sure the UAV stops correctly

			self.send_wp(dwp)
			self.spar_client.wait_for_result()
			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				# Something went wrong, cancel out of guidance!
				rospy.signal_shutdown("cancelled")
				return

			rospy.loginfo("Reached diversion ROI, dropping payload!")
			# XXX: Do something? DROP THE PAYLOAD.
			#rostopic pub /actuator_control/actuator_a std_msgs/Bool '{data: True}'
			if(msg_in.pose.position.z == 0):
				self.payload_pub.publish(False)
				#espeak.synth("Deploying GPS Tracker")
				self.espeak_publisher.publish("Deploying GPS Tracker")
			elif(msg_in.pose.position.z == 1):
				self.payload_pub.publish(True)
				#espeak.synth("Deploying Epi-Pen")
				self.espeak_publisher.publish("Deploying Epi-Pen")

			rospy.sleep(rospy.Duration(5))

			rospy.loginfo("Returning to flight plan...")

			self.send_wp(rwp)
			self.spar_client.wait_for_result()
			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				# Something went wrong, cancel out of guidance!
				rospy.signal_shutdown("cancelled")
				return

			# "nextWaypointIndex" represents the "next waypoint"
			# "nextWaypointIndex - 1" represents the "current waypoint"
			rospy.loginfo("Resuming flight plan from waypoint %i!" % (self.nextWaypointIndex - 1))
			self.send_wp(self.waypoints[self.nextWaypointIndex - 1])
			# Unset our flag that we are performing a diversion
			# to allow the waypoint timer to take back over
			self.performing_roi = False


	# This function is for convinience to simply send out a new waypoint
	def send_wp(self, wp):

		
		rospy.loginfo("SENT CURRENT LOCATION")

		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			rospy.logwarn("Invalid waypoint, skipped...")
			return False
			# raise ArgumentError("Invalid waypoint input!")

		# Build the flight goal
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_GOTO
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		goal.yaw = wp[3]
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw
		goal.wait_for_convergence = True
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# For this function, we don't wait in the loop.
		# Instead we just send the waypoint and check up on it later
		# This checking is either with the "self.timer" for waypoints
		# or with direct calls during the ROI diversion
		self.spar_client.send_goal(goal)
		
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())


	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not self.performing_roi:
			# If the last segment has succeeded.
			# For more complex tasks, it might be necessary to also
			# check if you are in waypoint or breadcrum mode.
			# Hint: really, we should check for other status states
			#		(such as aborted), as there are some states
			#		where we won't recover from, and should just exit
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo("Reached waypoint %i!" % (self.nextWaypointIndex))

				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				if self.nextWaypointIndex < (len(self.waypoints)):

					if not self.breadcrumbMode:
						# Set up a path request for breadcrumb
						req = RequestPathRequest()
						req.start.x = self.waypoints[self.nextWaypointIndex-1][0] # Get X
						req.start.y = self.waypoints[self.nextWaypointIndex-1][1] # Get Y
						req.start.z = self.waypoints[self.nextWaypointIndex-1][2] # Get Z
						req.end.x = self.waypoints[self.nextWaypointIndex][0]	# Get next X
						req.end.y = self.waypoints[self.nextWaypointIndex][1]	# Get next Y
						req.end.z = self.waypoints[self.nextWaypointIndex][2]	# Get next Z

						res = self.srvc_bc(req)
						
						# Breadcrumb will return a vector of poses if a solution was found
						# If no solution was found (i.e. no solution, or request bad
						# start/end), then breadcrumb returns and empty vector
						# XXX: You could also use res.path_sparse (see breadcrumb docs)
						breadcrumbWPS = []
						if len(res.path_sparse.poses) > 0:
							# Print the path to the screen
							rospy.loginfo("Segment {}-1 to {}:".format(self.nextWaypointIndex,self.nextWaypointIndex))
							rospy.loginfo("[%0.2f;%0.2f;%0.2f] => [%0.2f;%0.2f;%0.2f]",
										req.start.x,req.start.y,req.start.z,
										req.end.x,req.end.y,req.end.z)

							# Loop through the solution returned from breadcrumb
							for i in range(len(res.path_sparse.poses)):
								rospy.loginfo("    [%0.2f;%0.2f;%0.2f]",
											res.path_sparse.poses[i].position.x,
											res.path_sparse.poses[i].position.y,
											res.path_sparse.poses[i].position.z)
								breadcrumbWPS.append([res.path_sparse.poses[i].position.x, res.path_sparse.poses[i].position.y, res.path_sparse.poses[i].position.z, 0.0])

							# Display the path
							# print(breadcrumbWPS)
							self.breadcrumbWPS = breadcrumbWPS
							self.display_path(breadcrumbWPS,"/guidance/pathBreadcrum")
							self.breadcrumbMode = True
							self.breadcrumbWPSnextIndex = 0
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							self.breadcrumbWPSnextIndex +=1 

						else:
							rospy.logerr("solution not found")

					else:
						if self.breadcrumbWPSnextIndex < (len(self.breadcrumbWPS)):
							# We got here a breadcrumb path, we should exuted down here:
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							# Increment our waypoint counter
							self.breadcrumbWPSnextIndex +=1
						else:
							# If we finish with the breadcrumb waypoints we increase normal waypoints
							self.nextWaypointIndex += 1
							self.breadcrumbMode = False
				else:
					# Else the mission is over, shutdown and quit the node
					# XXX:	This could be used to restart the mission back to the
					#		first waypoint instead to restart the mission


					#If landing point was detected then go there.	
					#if self.detected_landing_point:
					#	if not self.final_coordinate_start:
					#		self.final_coordinate_finished = False
					#		self.send_wp([self.landing_coordinate.x, self.landing_coordinate.y, self.landing_coordinate.z, 0])
					#		self.final_coordinate_start = True
					#		rospy.loginfo("fuck you")
					#
					#
					#	if self.final_coordinate_finished and self.final_coordinate_start:
					#		rospy.loginfo("Mission csdsdfdsfdsfdsfsdf;")
					#		rospy.signal_shutdown("Complete, Wooh!")
					#else:
					#	rospy.loginfo("Mission complete1!")
					#	rospy.signal_shutdown("Complete, Wooh!")
					rospy.loginfo("Mission complete1!")
					rospy.signal_shutdown("Complete, Wooh!")


			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				rospy.loginfo("Mission cancelled!")
				rospy.signal_shutdown("cancelled")

	# Display a path
	def display_path(self, wps, name):
		rospy.loginfo("Displaying path...")
		pub_path = rospy.Publisher(name, Path, queue_size=10, latch=True)
		msg = Path()
		msg.header.frame_id = "/map"
		msg.header.stamp = rospy.Time.now()
	
		for wp in wps:
			pose = PoseStamped()
			pose.pose.position.x = wp[0]
			pose.pose.position.y = wp[1]
			pose.pose.position.z = wp[2]
	
			pose.pose.orientation.w = 1.0
			pose.pose.orientation.x = 0.0
			pose.pose.orientation.y = 0.0
			pose.pose.orientation.z = 0.0
	
			msg.poses.append(pose)
		rospy.loginfo("Publishing path...")
		pub_path.publish(msg)

	def callback_landing_coordinate(self, msg_in):
		if not self.detected_landing_point:
			#espeak.synth("Landing coordinates detected")
			self.espeak_publisher.publish("Landing coordinates detected")
			rospy.loginfo("Detected landing coordinate.")
			rospy.loginfo(msg_in.x)
			rospy.loginfo(msg_in.y)
			rospy.loginfo(msg_in.z)
			self.landing_coordinate = msg_in
			self.detected_landing_point = True

			self.waypoints.append([msg_in.x, self.waypoints[len(self.waypoints) - 1][1], 1, 0])
			self.waypoints.append([self.waypoints[len(self.waypoints) - 1][0], msg_in.y, 1, 0])


	def callback_battery(self, msg_in):
		self.battery_per = msg_in.percentage
		rospy.loginfo(msg_in.percentage)
		#self.uav_health()

	def uav_health(self, timer=None):
		if self.battery_per <= self.critical_battery:
			rospy.loginfo("Battery under critical level, Safe landing start.")
			rospy.loginfo(self.battery_per)

			#Code for emergency landing at -1,-1.
			
			#WHEN THIS RUNS DURING PAYLOAD DEPLOYMENT IT GOES TO THE LAST 
			#WAYPOINT BECAUSE IT GOES BACK TO THE SEND-WP AND THINKS ITS
			#AT THE LAST WAYPOINT.


			self.nextWaypointIndex = len(self.waypoints)

			self.send_wp([-1.0, -1.0, 0.6, 0])
	
		
			rospy.loginfo("Emergency land completed.")




#Generates waypoints given search area, altitude, FOV and overlap.
#(Search area as observed standing from the desk x-> horizontal, y-> vertical).
#(FOV is taken as half of the angle of the camera (something like 19 degrees i think)).
#(NEED TO IMPORT MATH).
#SEE THE COMMENT "EXTREMELY IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!"
def generate_waypoints(search_x, search_y, altitude, fov, overlap):

	#Calculate pass length. 
	image_length = 2 * (altitude * math.tan(fov*(math.pi/180)))
	pass_length = image_length * (1.0 - overlap)

	#Calculate number of passes required.
	num_passes = int(math.ceil(search_y / pass_length))

	#Create waypoints (two waypoints per pass).
	waypoint_list = []
	for waypoint_index in range(num_passes):
		
		#X position is the same for both waypoints in one pass. 
		#waypoint_x = (((search_x / pass_length) * (waypoint_index + 1)) + (pass_length/2))
		waypoint_y = (pass_length / 2) + (pass_length * waypoint_index)
		waypoint_y_zeroed = waypoint_y - (search_y / 2)

		#Y position is the same but opposite.
		waypoint_x_top = (search_x/2) - (pass_length/2)
		waypoint_x_bottom = -1 * waypoint_x_top

		#Waypoints.
		#EXTREMELY IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!
		#The actual room is flipped, x is y, y is x. So here, the values are just added in reverse. 
		top_waypoint = [float(waypoint_x_top), float(waypoint_y_zeroed), float(altitude), 0.0]
		bottom_waypoint = [float(waypoint_x_bottom), float(waypoint_y_zeroed), float(altitude), 0.0]

		#If the index is even, bottom is first...etc.
		if (waypoint_index % 2) == 0: #Even.
			waypoint_list.append(bottom_waypoint)
			waypoint_list.append(top_waypoint)
		else: #Odd.
			waypoint_list.append(top_waypoint)
			waypoint_list.append(bottom_waypoint)

	#Return the waypoint list.
	return waypoint_list		

	

def main(args):
	# Initialise ROS
	rospy.init_node('guidance')
	surveyAltitude = rospy.get_param("~surveyAlt", 1)
	# List of waypoints
	# surveyAltitude = 2.5
	# [X, Y, Z, Yaw]
	# wpsR1 = [[ 0.0, 0.0, surveyAltitude, 0.0],
	# 	   [ 1.0, 1.0, surveyAltitude, 0.0],
	# 	   [-1.0, 1.0, surveyAltitude, 0.0],
	# 	   [-1.0,-1.0, surveyAltitude, 0.0],
	# 	   [ 1.0,-1.0, surveyAltitude, 0.0],
	# 	   [ 0.0, 0.0, surveyAltitude, 0.0]]

	# wpsR2 = [[ 0.0, 0.0, surveyAltitude*2, 0.0],
	# 	   [ 1.0, 1.0, surveyAltitude*2, 0.0],
	# 	   [-1.0, 1.0, surveyAltitude*2, 0.0],
	# 	   [-1.0,-1.0, surveyAltitude*2, 0.0],
	# 	   [ 1.3,-1.0, surveyAltitude*2, 0.0],
	# 	   [ 1.3,1.0, surveyAltitude*2, 0.0],
	# 	   [ 1.0,-1.0, surveyAltitude*2, 0.0],
	# 	   [ 0.0, 0.0, surveyAltitude*2, 0.0]]

	# #Lawnmower pattern.
	# lawn_alt = 3
	# lawn_wps = [[ 0.0, 0.0, lawn_alt , 0.0],
	# 	   [-3.5, 0.0, lawn_alt , 0.0],
	# 	   [ -3.5, -2.0,lawn_alt, 0.0],
	# 	   [3.5, -2.0, lawn_alt, 0.0],
	# 	   [3.5,-1.0, lawn_alt, 0.0],
	# 	   [ -3.5,-1.0, lawn_alt, 0.0],
	# 	   [ -3.5,0.0, lawn_alt, 0.0],
	# 	   [ 3.5 ,0.0, lawn_alt, 0.0],
	# 	   [ 3.5, 1.0, lawn_alt, 0.0],
	# 	   [ -3.5, 1.0, lawn_alt, 0.0],
	# 	   [ -3.5, 2.0, lawn_alt, 0.0],
	# 	   [ 3.5, 2.0, lawn_alt, 0.0]]

	# if surveyAltitude > 2:
	# 	wps = wpsR1
	# else:
	# 	wps = wpsR2

	x = 8
	y = 5
	alt = 3
	fov = 19.59
	overlap = 0.4 #40%.

	lawn_wps = generate_waypoints(x, y, alt, fov, overlap)

	# lawn_alt = 3
	# lawn_wps = [[ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	# 	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	# 	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0],
	#  	   [ 0.0, 0.0, lawn_alt , 0.0]]


	# Create our guidance class option
	guide = Guidance(lawn_wps)

	# Spin!
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('Node Closed')





#rostopic pub /pose_example geometry_msgs/PoseStamped "header:
#  seq: 0
#  stamp:
#    secs: 0
#    nsecs: 0
#  frame_id: 'base_link'
#pose:
#  position:
#    x: 1.0
#    y: 2.0
#    z: 0.0
#  orientation:
#    x: 0.0
#    y: 0.0
#    z: 0.0
#    w: 1.0"

'''